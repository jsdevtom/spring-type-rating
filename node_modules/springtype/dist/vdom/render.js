"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
exports.__esModule = true;
exports.render = exports.newUniqueComponentName = exports.cmpSequence = exports.filterComments = exports.toFlatNodeList = exports.isJSXComment = exports.tsxToStandardAttributeName = void 0;
var dom_1 = require("./dom");
var st_1 = require("../st/st");
var tsxToStandardAttributeName = function (tsxAttributeName) {
    // support for SVG xlink:*
    if (tsxAttributeName.startsWith(dom_1.XLINK_ATTRIBUTE_NAME)) {
        return (dom_1.XLINK_ATTRIBUTE_NAME + ":" + tsxAttributeName.replace(dom_1.XLINK_ATTRIBUTE_NAME, "")).toLowerCase();
    }
    switch (tsxAttributeName) {
        // support for React className -> class
        case dom_1.CLASS_NAME_ATTRIBUTE_NAME:
            return dom_1.CLASS_ATTRIBUTE_NAME;
    }
    return tsxAttributeName;
};
exports.tsxToStandardAttributeName = tsxToStandardAttributeName;
// If a JSX comment is written, it looks like: { /* this */ }
// Therefore, it turns into: {}, which is detected here
var isJSXComment = function (node) {
    return node && typeof node === 'object' && (!node.attributes && !node.type && !node.children);
};
exports.isJSXComment = isJSXComment;
// Implementation to flatten virtual node children structures like:
// [<p>1</p>, [<p>2</p>,<p>3</p>]] to: [<p>1</p>,<p>2</p>,<p>3</p>]
var toFlatNodeList = function (children) {
    return [].concat.apply([], children);
};
exports.toFlatNodeList = toFlatNodeList;
// Filters comments and undefines like: ['a', 'b', false, {}] to: ['a', 'b', false]
var filterComments = function (children) {
    return children.filter(function (child) { return !exports.isJSXComment(child); });
};
exports.filterComments = filterComments;
exports.cmpSequence = 0;
var newUniqueComponentName = function () { return "fnc-" + ++exports.cmpSequence; };
exports.newUniqueComponentName = newUniqueComponentName;
exports.render = (st_1.st.render = function (
// if it is a function, it is a component
type, attributes) {
    var children = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        children[_i - 2] = arguments[_i];
    }
    children = exports.filterComments(exports.toFlatNodeList(children));
    // clone attributes as well
    attributes = __assign({}, attributes);
    // effectively unwrap by directly returning the children
    if (type === dom_1.FRAGMENT_ELEMENT_NAME) {
        return exports.filterComments(children);
    }
    // it's a component, divide and conquer children
    if (typeof type === 'function') {
        return type(__assign({ children: children }, attributes));
    }
    // @ts-ignore as type allows for Function here, but internally we wouldn't
    // want to deal with Function, only "string". However, in this method it is indeed possible
    return {
        type: type,
        attributes: attributes,
        children: children
    };
});
